import os.path
import pickle
import queue
from pathlib import Path
import time
from queue import PriorityQueue
from tkinter.constants import DISABLED, NORMAL

import threading

from Models.data_model import Data
from Models.track_model import Track
#import fluidsynth as m_fluidsynth
from Utils import m_fluidsynth
from Utils.IterableSemaphore import ISemaphore, IBoundedSemaphore
from Utils.tktable_table import Cell_Line
from Views.music_view import MusicView


class MusicCtrl:
    """
    Controller for final music model. <=> sonification ctrl
    """

    def __init__(self, model):
        # Other data
        self.sonification_view = None
        self.playing = False  # True if the music has started, regardless of wheter its paused. False when the music is stopped or ended.
        self.paused = False
        self.skipNextNote = False
        self.queueSemaphore = ISemaphore()  # Could be seomething else ig
        self.trackSemaphore = threading.Lock()  # Could be seomething else ig
        self.emptySemaphore = IBoundedSemaphore(model.QUEUE_CAPACITY)
        self.fullSemaphore = IBoundedSemaphore(model.QUEUE_CAPACITY)
        self.fullSemaphore.acquire(n=model.QUEUE_CAPACITY)  # Set semaphore to 0
        self.playingEvent = threading.Event()
        self.stoppedEvent = threading.Event()
        self.pausedEvent = threading.Event()
        self.unpaintEvent = threading.Event()
        self.scheduledUnpaintTimer = 0
        self.unpaintId = None
        self.paintedLine = None
        self.unpaintQueue = PriorityQueue(model.QUEUE_CAPACITY*8)
        # Model
        self.model = model  # Music model
        self.view = MusicView(model, self)
        self.data = Data.getInstance()

        # Threads
        self.producer_thread = threading.Thread(target=self.model.generate, daemon=True)
        self.unpainter_thread = threading.Thread(target=self.unpaint_played_row, daemon=True)
        self.unpainter_thread.start()

    def create_track(self):
        """
        Create a track and adds it to the model. View and ctrl is generated by it.
        """
        prev_track_nbr = len(self.model.tracks)
        track = Track()
        threading.Thread(target=self.model.add_track, args=[track, True], daemon=True).start()
        if prev_track_nbr == 0 and len(self.model.tracks) == 1:
            self.sonification_view.playButton.config(state=NORMAL)
            self.sonification_view.exportMusicButton.config(state=NORMAL)
            #self.sonification_view.ffwButton.config(state=NORMAL)
            #self.sonification_view.fbwButton.config(state=NORMAL)

    def add_track(self, track, generate_view=False):
        """
        Add an existing track to music model
        :param track: a previously generated track
        :param generate_view: generate a view if True. Should be False if views already exist
        """
        self.model.add_track(track, generate_view)
        #threading.Thread(target=self.model.add_track, args=[track, generate_view], daemon=True).start()

    def remove_track(self, track: Track):
        """
        Remove a track from the model
        :param track: a Track model
        """
        self.model.remove_track(track)
        #threading.Thread(target=self.model.remove_track, args=[track], daemon=True).start()
        if len(self.model.tracks) == 0:
            self.sonification_view.playButton.config(state=DISABLED)
            self.sonification_view.exportMusicButton.config(state=DISABLED)

    def fast_forward(self):
        skipped = self.model.data.get_next(iterate=True)
        tfactors = []
        for idx, row in skipped.iterrows():
            tfactors.append(self.model.get_absolute_note_timing(self.model.timeSettings.get_temporal_position(row)))
        print(tfactors)

    def fast_forward_leg(self):
        nonempty = True
        self.view.starting_time -= 5000
        while(nonempty):
            self.fullSemaphore.acquire()
            self.queueSemaphore.acquire()
            note = self.model.notes.get_nowait()
            now = self.view.sequencer.get_tick()
            note_timing_abs = self.model.get_absolute_note_timing(note)
            note_timing = self.view.get_relative_note_timing(note_timing_abs)
            nonempty = note_timing < 5000
            if(not nonempty):
                self.model.notes.put_nowait(note)
            log_line = "REMOVE Note [track={}, value={}, vel={}, dur={}, timing abs={}] at t={}, data row #{} planned scheduled in {}ms. {} notes remaining".format(
                note.channel, note.value, note.velocity, note.duration, note_timing_abs, now,
                note.id, note_timing, self.model.notes.qsize())
            self.sonification_view.add_log_line(log_line)
            self.queueSemaphore.release()
            self.emptySemaphore.release()

        print(now)
        #Get current timepoint
        #Compute next timepoint
        #Acquire semaphores
        #Remove all notes with time value<next time point
        #Release semaphores
        pass

    def fast_backward(self):
        #TODO REDO
        #Empty queue
        #change current batch idx by -X
        #Get absolute position of first note of current batch
        #Set absolute position of current time to absolute position of first note of current batch
        #-> Developp wrappers for absolute/relative time conversion

        self.pause()
        lastNote = None
        while (not self.model.notes.empty()):
            self.queueSemaphore.acquire()
            self.emptySemaphore.release()
            self.fullSemaphore.acquire()
            lastNote = self.model.notes.get_nowait()
            self.queueSemaphore.release()
        self.model.data.index-=5
        lastrow = None
        for idx, row in self.model.data.get_next(False).iterrows():
            lastrow = row
        diff = self.model.get_absolute_note_timing(lastNote.tfactor) - self.model.get_absolute_note_timing(self.model.timeSettings.get_temporal_position(lastrow))
        print(diff)
        self.view.starting_time-=diff
        self.skipNextNote = True
        self.play()
        #Get current timepoint
        #Compute previous timepoint
        #Acquire semaphore
        #Purge queue
        #Compute idx for batches so that note[idx].timestamp < previous timepoint
        #Add notes to queue
        #Release semaphores
        pass

    def setup_music(self):
        self.model.timeSettings.set_attribute(self.model.data.first_date, self.model.data.last_date, self.model.data.size)
        self.load_soundfonts()

    def play(self):
        """
        Start a thread via music model to produce notes for the music view, then start the sequencer
        """
        self.sonification_view.dataTable.set_data(self.data.get_first_and_last().to_dict('records'))
        self.setup_music()

        self.sonification_view.playButton.config(state=DISABLED)
        self.sonification_view.pauseButton.config(state=NORMAL)
        self.sonification_view.stopButton.config(state=NORMAL)

        self.view.save_play_time()
        self.playing = True
        self.paused = False
        self.playingEvent.set() #Release threads
        self.pausedEvent.set() #Release threads
        self.stoppedEvent.clear() #Send signal that we started


    def pause(self):
        self.sonification_view.playButton.config(state=NORMAL)
        self.sonification_view.pauseButton.config(state=DISABLED)
        self.view.save_pause_time()
        self.paused = True
        self.playingEvent.clear() #Block threads TODO: Necessary?
        self.pausedEvent.clear() #Block threads

    def stop(self):
        self.sonification_view.pauseButton.config(state=DISABLED)
        self.sonification_view.stopButton.config(state=DISABLED)
        self.sonification_view.playButton.config(state=NORMAL)

        print("Stopping at {} with {} notes in queue . empty:{}/{}, full:{}/{}, mutex:{}".format(
            self.view.sequencer.get_tick(), self.model.notes.qsize(),
            self.emptySemaphore._value,
            self.emptySemaphore._initial_value,
            self.fullSemaphore._value,
            self.fullSemaphore._initial_value,
            self.queueSemaphore._value))
        self.view.synth.system_reset()  # Reset synth to prevent future note from being played
        self.view.synth.program_reset()
        self.playingEvent.clear()  # Send stop event
        self.stoppedEvent.set()
        # Update bools
        self.playing = False
        self.paused = False
        # Update data
        self.data.reset_playing_index()
        # Reset semaphores
        # self.emptySemaphore.release(n=len(self.model.notes))
        # self.fullSemaphore.acquire(n=len(self.model.notes))
        # Reset queue
        while(not self.unpaintQueue.empty()):
            unpaint = self.unpaintQueue.get_nowait()
            line = Cell_Line(None, self.sonification_view.dataTable.get_cell_line(unpaint[1]))
            line.paint_line("white")
        try:
            while (not self.model.notes.empty()):
                self.emptySemaphore.release()
                self.fullSemaphore.acquire()
                self.model.notes.get_nowait()
        except ValueError:
            self.queueSemaphore = ISemaphore()  # Could be seomething else ig
            self.trackSemaphore = threading.Lock()  # Could be seomething else ig
            self.emptySemaphore = IBoundedSemaphore(self.model.QUEUE_CAPACITY)
            self.fullSemaphore = IBoundedSemaphore(self.model.QUEUE_CAPACITY)
            self.fullSemaphore.acquire(n=self.model.QUEUE_CAPACITY)  # Set semaphore to 0
        # self.model.notes.clear()
        time.sleep(0.05) #TODO: needed for semaphore reset
        self.sonification_view.add_log_line("semaphore: {}/{}, {}/{}, {}".format(self.emptySemaphore._value,
                                                   self.emptySemaphore._initial_value,
                                                   self.fullSemaphore._value,
                                                   self.fullSemaphore._initial_value,
                                                   self.queueSemaphore._value),
                                            debug=True)

    def change_queue_size(self, size):
        self.emptySemaphore.update_size(size, True)
        self.fullSemaphore.update_size(size)

    def open_time_settings(self):
        self.model.timeSettings.ctrl.show_window()

    def change_global_gain(self, gain):
        m_fluidsynth.fluid_settings_setnum(self.view.synth.settings, b'synth.gain', float(gain)/100)

    def change_local_gain(self, track, value):
        self.view.synth.cc(track, 7, int(value * 1.27))  # 7 volume command, accepting value between 1-127

    def load_soundfonts(self):
        """
        Assign soundfonts to channel inside fluidsynth.
        """
        # Upon hitting play, register all track and soundfonts.
        for track in self.model.tracks:
            soundfont_fid = self.view.synth.sfload(track.soundfont)  # Load the soundfont
            self.view.synth.program_select(track.id, soundfont_fid, 0, 0)  # Assign soundfont to a channel

    def import_all_tracks(self, path):
        with open(path, 'rb') as f:
            m = pickle.load(f)
            self.model.__dict__.update(m.__dict__)
            self.model.sonification_view = self.sonification_view
            self.model.ctrl = self
            self.model.timeSettings.music = self.model
            self.model.tracks = []
            for t in m.tracks:
                self.add_track(t, True)
            for t in self.model.tracks:
                t.configView.reset_view()

    def export_all_tracks(self, path):
        with open(path, 'wb') as f:
            pickle.dump(self.model, f)
            self.sonification_view.add_log_line("exported model to {}".format(path))

    def export_music(self, filename):
        name = Path(filename)
        try:
            self.model.write_fluidsynth_config(name.stem)
            self.sonification_view.add_log_line("writing {}".format(name))
            self.model.generate_midi(name.stem)
            self.view.synth.midi_to_audio(name.stem + ".mid", filename, name.stem + "-fluidsynth_midi_to_wav.config")
            self.sonification_view.add_log_line("writing {} done".format(name))
        except:
            self.sonification_view.add_log_line("Error while saving {}!".format(name))

    def push_data_to_table(self, datas):
        for idx, data in datas.iterrows():
            self.sonification_view.dataTable.push_row(data)

    def unpaint_played_row(self):
        while True:
            self.unpaintEvent.wait()
            unpaint = self.unpaintQueue.get_nowait()
            if(unpaint[0]>0):
                time.sleep(unpaint[0])
            line = Cell_Line(None, self.sonification_view.dataTable.get_cell_line(unpaint[1]))
            line.paint_line("white")
            self.unpaintEvent.clear()

    def paint_next_played_row(self, id, duration, color="lightgreen"):
        try:
            line = self.sonification_view.dataTable.paint_row(id, "id", color)
            if line:
                self.unpaintQueue.put_nowait((float(duration)/2000, line.get_row_nbr()))
                self.unpaintEvent.set()
        except queue.Full:
            pass
