from __future__ import annotations
import datetime
import itertools
import logging
import pickle
import threading
import time
from pathlib import Path

from pandas import DataFrame

from Models.data_model import Data
import Models.music_model as music
from Models.note_model import NoteData
from Models.track_model import Track
# import fluidsynth as m_fluidsynth
from Utils import m_fluidsynth
from Utils.IterableSemaphore import ISemaphore, IBoundedSemaphore
from Utils.constants import MAX_NOTE_GRAPH
from Views.music_view import MusicView
from ViewsPyQT5.ViewsUtils.views_utils import playButtonReadyStyle, buttonStyle


class MusicCtrl:
    """
    Controller for final music model.
    """

    def __init__(self, model:music.Music):
        # Other data
        self._pausedTimed = 0
        self._musicTiming = 0  # timestamp of the start of the music
        self.maxNoteGraph = MAX_NOTE_GRAPH
        self.playing = False  # True if the music has started, regardless of wheter its paused. False when the music is stopped or ended.
        self.paused = False
        self.finished = False
        self.skipNextNote = False
        self.queueSemaphore = ISemaphore()  # Could be seomething else ig
        self.graphSemaphore = ISemaphore()  # Could be seomething else ig
        self.trackSemaphore = threading.Lock()  # Could be seomething else ig
        self.emptySemaphore = IBoundedSemaphore(model.queue_capacity)
        self.fullSemaphore = IBoundedSemaphore(model.queue_capacity)
        self.fullSemaphore.acquire(n=model.queue_capacity)  # Set semaphore to 0
        self.playingEvent = threading.Event()
        self.stoppedEvent = threading.Event()
        self.pausedEvent = threading.Event()
        # Model
        self.model = model  # Music model
        self.view = MusicView(model, self)
        self.data = Data.getInstance()

        # Threads
        self.producer_thread = threading.Thread(target=self.model.generate, daemon=True, name="Notes_producer_thread")

    def get_music_time(self)->float:
        """
        Utility fct to get when we are positionned in the song
        :return: time position between 0 and musicDuration
        """
        if (not self.playing):
            return 0
        elif (self.paused):
            logging.log(logging.DEBUG,"returned the pause time in music_ctrl.get_music_time() at {}".format(datetime.datetime.now()))
            return self._pausedTimed
        else:
            return time.perf_counter() - self._musicTiming

    def create_track(self)->None:
        """
        Create a track and adds it to the model. View and ctrl is generated by it.
        """
        track = Track(next(self.model.track_newid))
        # threading.Thread(target=self.model.add_track, args=[track, True], daemon=True).start()
        self.add_track(track, True)

    def add_track(self, track:Track, generate_view:bool=False)->None:
        """
        Add an existing track to music model
        :param track: a previously generated track
        :param generate_view: generate a view if True. Should be False if views already exist
        """
        prev_track_nbr = len(self.model.tracks)
        self.model.add_track(track, generate_view)
        if prev_track_nbr == 0 and len(self.model.tracks) == 1:
            self.model.sonification_view.topBarView.PPButton.setEnabled(True)
            self.model.sonification_view.topBarView.PPButton.setStyleSheet(playButtonReadyStyle)
        # threading.Thread(target=self.model.add_track, args=[track, generate_view], daemon=True).start()

    def remove_track(self, track: Track)->None:
        """
        Remove a track from the model
        :param track: a Track model
        """
        self.model.remove_track(track)
        # threading.Thread(target=self.model.remove_track, args=[track], daemon=True).start()
        if len(self.model.tracks) == 0:
            self.model.sonification_view.topBarView.PPButton.setEnabled(False)
            self.model.sonification_view.topBarView.PPButton.setStyleSheet(buttonStyle)
            self.model.sonification_view.visualisationView.GraphFrame.hide()
            self.model.sonification_view.trackView.TrackSettings_2.hide()
            self.model.sonification_view.trackView.retranslate_ui()
            self.model.sonification_view.advancedTrackView.filterFrame.hide()
            self.model.sonification_view.advancedTrackView.SettingsFrame.hide()
            self.model.sonification_view.advancedTrackView.detailsScrollArea.hide()
            self.model.sonification_view.parent.saveAction.setEnabled(False)
            self.model.sonification_view.parent.exportAction.setEnabled(False)

    def purge_tracks(self)->None:
        """
        Remove all tracks
        """
        keys = []  # copy.deepcopy frustrated me
        for key in self.model.tracks.keys():
            keys.append(key)
        for key in keys:
            self.model.tracks[key].remove()
        music.Music.track_newid = itertools.count()


    def set_timing(self, tfactor):
        delta = 1.0
        datas = self.data.df

    # def fast_backward(self):
    #     self.view.starting_time += 2000
    #     self._musicTiming += 2
    #     tfactors = 0

    # def fast_forward(self):
    #     #raise NotImplementedError()
    #     self.view.starting_time -= 2000
    #     self._musicTiming -= 2
    #     return
    #     time_skip = 5000 # ms
    #     skipped = self.model.data.get_next()
    #     tfactors = []
    #     for idx, row in skipped.iterrows():
    #         tfactors.append(self.model.get_absolute_note_timing(self.model.timeSettings.get_temporal_position(row)))
    #     print("tfactors for next batches are")

    # def fast_forward_leg(self):
    #     nonempty = True
    #     self.view.starting_time -= 5000
    #     while(nonempty):
    #         self.fullSemaphore.acquire()
    #         self.queueSemaphore.acquire()
    #         note = self.model.notes.get_nowait()
    #         now = self.view.sequencer.get_tick()
    #         note_timing_abs = self.model.get_absolute_note_timing(note)
    #         note_timing = self.view.get_relative_note_timing(note_timing_abs)
    #         nonempty = note_timing < 5000
    #         if(not nonempty):
    #             self.model.notes.put_nowait(note)
    #         log_line = "REMOVE Note [track={}, value={}, vel={}, dur={}, timing abs={}] at t={}, data row #{} planned scheduled in {}ms. {} notes remaining".format(
    #             note.channel, note.value, note.velocity, note.duration, note_timing_abs, now,
    #             note.id, note_timing, self.model.notes.qsize())
    #         self.sonification_view.add_log_line(log_line)
    #         self.queueSemaphore.release()
    #         self.emptySemaphore.release()
    #
    #     print(now)
    #     #Get current timepoint
    #     #Compute next timepoint
    #     #Acquire semaphores
    #     #Remove all notes with time value<next time point
    #     #Release semaphores
    #     pass

    # def fast_backward(self):
    #     raise NotImplementedError()
    #     #TODO REDO
    #     #Empty queue
    #     #change current batch idx by -X
    #     #Get absolute position of first note of current batch
    #     #Set absolute position of current time to absolute position of first note of current batch
    #     #-> Developp wrappers for absolute/relative time conversion
    #
    #     self.pause()
    #     lastNote = None
    #     while (not self.model.notes.empty()):
    #         self.queueSemaphore.acquire()
    #         self.emptySemaphore.release()
    #         self.fullSemaphore.acquire()
    #         lastNote = self.model.notes.get_nowait()
    #         self.queueSemaphore.release()
    #     self.model.data.index-=5
    #     lastrow = None
    #     for idx, row in self.model.data.get_next(False).iterrows():
    #         lastrow = row
    #     diff = self.model.get_absolute_note_timing(lastNote.tfactor) - self.model.get_absolute_note_timing(self.model.timeSettings.get_temporal_position(lastrow))
    #     print(diff)
    #     self.view.starting_time-=diff
    #     #self.skipNextNote = True
    #     self.play()
    #     #Get current timepoint
    #     #Compute previous timepoint
    #     #Acquire semaphore
    #     #Purge queue
    #     #Compute idx for batches so that note[idx].timestamp < previous timepoint
    #     #Add notes to queue
    #     #Release semaphores
    #     pass

    def setup_general_attribute(self)->None:
        self.model.timeSettings.set_attribute(self.model.data.first_date, self.model.data.last_date,
                                              self.model.data.size)


    def play_note(self, note):
        if(not self.playing):
            self.setup_general_attribute()
            self.load_soundfonts()
            for track in self.model.tracks:
                self.change_local_gain(self.model.tracks[track].id, self.model.tracks[track].gain)
            self.change_global_gain(self.model.gain)
        self.view.play_note(note)

    def play(self)->None:
        """
        Start a thread via music model to produce notes for the music view, then start the sequencer
        """


        self.model.sonification_view.visualisationView.setup(self.maxNoteGraph)
        self.setup_general_attribute()
        self.load_soundfonts()
        for track in self.model.tracks:
            self.change_local_gain(self.model.tracks[track].id, self.model.tracks[track].gain)
        self.change_global_gain(self.model.gain)

        self.skipNextNote = False
        self.view.save_play_time()
        if (self.paused):
            self._musicTiming += (time.perf_counter() - self._pausedTimed)
        else:
            self._musicTiming = time.perf_counter()
        #self.model.generate_dataframe()
        #self.view.play_dataframe()
        self.playing = True
        self.paused = False
        self.finished = False
        self.playingEvent.set()  # Release threads
        self.pausedEvent.set()  # Release threads
        self.stoppedEvent.clear()  # Send signal that we started

    def pause(self)->None:
        self.view.save_pause_time()
        self._pausedTimed = time.perf_counter()
        self.paused = True
        self.playingEvent.clear()  # Block threads TODO: Necessary?
        self.pausedEvent.clear()  # Block threads

    def stop(self)->None:
        logging.log(logging.INFO,"Stopping at {} with {} notes in queue . empty:{}/{}, full:{}/{}, mutex:{}".format(
            self.view.sequencer.get_tick(), self.model.notes.qsize(),
            self.emptySemaphore._value,
            self.emptySemaphore._initial_value,
            self.fullSemaphore._value,
            self.fullSemaphore._initial_value,
            self.queueSemaphore._value))
        self.playingEvent.clear()  # Send stop event
        self.stoppedEvent.set()
        self.skipNextNote = True  # if a note is ripping, make it stale
        self.view.synth.system_reset()  # Reset synth to prevent future note from being played
        self.view.synth.program_reset()
        # Update bools
        self.playing = False
        self.paused = False

        # Update data
        self.data.reset_playing_index()
        self.model.sonification_view.tableView.data_model.reset(self.data.get_first(), self.data.get_second())
        self.model.sonification_view.visualisationView.reset()

        # Reset queue
        try:
            while (not self.model.notes.empty()):
                self.emptySemaphore.release()
                self.fullSemaphore.acquire()
                self.model.notes.get_nowait()
        except ValueError:
            self.queueSemaphore = ISemaphore()  # Could be seomething else ig
            self.trackSemaphore = threading.Lock()  # Could be seomething else ig
            self.emptySemaphore = IBoundedSemaphore(self.model.queue_capacity)
            self.fullSemaphore = IBoundedSemaphore(self.model.queue_capacity)
            self.fullSemaphore.acquire(n=self.model.queue_capacity)  # Set semaphore to 0

        time.sleep(0.05)  # needed for semaphore values display
        logging.log(logging.INFO,"semaphore: {}/{}, {}/{}, {}".format(self.emptySemaphore._value,
                                                   self.emptySemaphore._initial_value,
                                                   self.fullSemaphore._value,
                                                   self.fullSemaphore._initial_value,
                                                   self.queueSemaphore._value))

    def change_queue_size(self, size:int)->None:
        self.emptySemaphore.update_size(size, True)
        self.fullSemaphore.update_size(size)

    def change_global_gain(self, gain:int, from_muted:bool=False)->None:  # dark magic as we interact with fluidsynth
        m_fluidsynth.fluid_settings_setnum(self.view.synth.settings, b'synth.gain', float(gain) / 100)
        if not from_muted:
            self.model.gain = gain
            if (gain == 0 and not self.model.muted):
                self.mute_click()
            if (gain > 0 and self.model.muted):
                self.mute_click()

    def change_local_gain(self, track: int, value:int)->None:
        """
        Change the gain of a specific track, overriding previous value. Interface with fluidsynth
        :param track: an id, i.e. channel number
        :param value: new gain, between 0 and 100
        """
        self.view.synth.cc(track, 7, int(value * 1.27))  # 7 volume command, accepting value between 1-127

    def load_soundfonts(self)->None:
        """
        Assign soundfonts to channel inside fluidsynth.
        """
        # Upon hitting play, register all track and soundfonts.
        for track in self.model.tracks.values():
            soundfont_fid = self.view.synth.sfload(track.soundfont)  # Load the soundfont
            self.view.synth.program_select(track.id, soundfont_fid, 0, 0)  # Assign soundfont to a channel

    def import_all_tracks(self, path:str)->None:
        with open(path, 'rb') as f:
            m = pickle.load(f)
            s_view = self.model.sonification_view
            self.purge_tracks()
            self.model.__dict__.update(m.__dict__)
            self.model.tracks = {}  # Needed as updating the model dict populates tracks but does not update ui
            self.model.sonification_view = s_view
            self.model.ctrl = self
            self.model.timeSettings.music = self.model
            for k in m.tracks:
                self.add_track(m.tracks[k], True)
                next(self.model.track_newid)
            self.model.sonification_view.set_status_text("Project {} open!".format(path), 5000)

    def export_all_tracks(self, path:str)->None:
        with open(path, 'wb') as f:
            pickle.dump(self.model, f)
            self.model.sonification_view.set_status_text("exported model to {}".format(path))

    def export_music(self, filename:str)->None:
        name = Path(filename)
        try:
            self.model.write_fluidsynth_config(name.stem)
            self.model.generate_midi(name.stem)
            self.view.synth.midi_to_audio(name.stem + ".mid", filename, name.stem + "-fluidsynth_midi_to_wav.config")
            self.model.sonification_view.set_status_text("Music {} saved!".format(name), 4000)
        except:
            self.model.sonification_view.set_status_text("Error while saving {}!".format(name), 10000)

    def push_data_to_table(self, datas: DataFrame)->None:
        """Push rows to the table view"""
        for data in datas.itertuples():
            if not ((data.internal_id == self.data.get_first().internal_id).any() or
                    (data.internal_id == self.data.get_second().internal_id).any()):
                self.model.sonification_view.tableView.data_model.load_row(data)

    def mute_click(self)->None:
        self.model.muted = not self.model.muted
        self.model.sonification_view.topBarView.volumeButton.setIcon(self.model.sonification_view.topBarView.mutedIcon
                                                                     if self.model.muted else self.model.sonification_view.topBarView.volumeIcon)
        self.model.sonification_view.topBarView.GainSlider.setValue(0 if self.model.muted else self.model.gain)
